//////////////////////////////////////////////////////////////////////

Bartolomé Sabater
Emili Darder - Desenvolupament Entorn Servidor - 2024-25

Uso del Motor de plantillas BLADE 
(https://laravel.com/docs/11.x/blade)

Mejoras en las View, aplicar un diseño más avanzado y refinado

Uso del Motor de plantillas BLADE
	Tailwindcss (Problemas y resolución) 
	Anonymous Components
	Class Based Components
	Dynamic Componets
	Layout

//////////////////////////////////////////////////////////////////////


//// En este tema se verá un refinamiento a las View
//// Utilizaremos el Motor de Plantillas Blade

// Algo de repaso primero

// Recordamos las Route de nuestro proyect
λ php artisan route:list

  GET|HEAD        postCRUD .................................. postCRUD.index › PostControllerCRUD@index
  POST            postCRUD .................................. postCRUD.store › PostControllerCRUD@store
  GET|HEAD        postCRUD/create ......................... postCRUD.create › PostControllerCRUD@create
  GET|HEAD        postCRUD/{postCRUD} ......................... postCRUD.show › PostControllerCRUD@show
  PUT|PATCH       postCRUD/{postCRUD} ..................... postCRUD.update › PostControllerCRUD@update
  DELETE          postCRUD/{postCRUD} ................... postCRUD.destroy › PostControllerCRUD@destroy
  GET|HEAD        postCRUD/{postCRUD}/edit .................... postCRUD.edit › PostControllerCRUD@edit
  GET|HEAD        posts .......................................................... PostController@index

  GET|HEAD        categoryCRUD ....................... categoryCRUD.index › CategoryControllerCRUD@index
  POST            categoryCRUD ....................... categoryCRUD.store › CategoryControllerCRUD@store
  GET|HEAD        categoryCRUD/create .............. categoryCRUD.create › CategoryControllerCRUD@create
  GET|HEAD        categoryCRUD/{categoryCRUD} .......... categoryCRUD.show › CategoryControllerCRUD@show
  PUT|PATCH       categoryCRUD/{categoryCRUD} ...... categoryCRUD.update › CategoryControllerCRUD@update
  DELETE          categoryCRUD/{categoryCRUD} .... categoryCRUD.destroy › CategoryControllerCRUD@destroy
  GET|HEAD        categoryCRUD/{categoryCRUD}/edit ..... categoryCRUD.edit › CategoryControllerCRUD@edit


// La ruta postCRUD.create es un GET|HEAD porque es la que llama al formulario de creación del recurso 
//      este formulario de creacion es el que luego llamará a postCRUD.store
// La ruta postCRUD.store es un POST y es donde se llevará a cabo la verdadera creación del recurso 

// La ruta postCRUD.edit es un GET|HEAD porque es la que llama al formulario que mostrará el recurso 
//      este formulario que muestra el recurso, es el que llamará a postCRUD.update
// La ruta postCRUD.update sí es un PUT|PATCH y es donde ya habría la modificación del recurso  

// Recordar que @csrf añade un token hidden de seguridad en el formulario, 
//      por ejemplo, verlo en resources>views>post>create.blade.php
// En general todos los formularios deberán tener esta directiva @csrf de seguridad, 
//      simulando la persistencia
// Con esta directiva, desde una página externa, no se podrá hacer un "POST" "PUT", 
//      porque debe ser desde una página anterior generada por el servidor

//// Hasta hora hemos confeccionado un CRUD que funciona, es muy sencillo y funcional, pero no es muy estético
//// Este tipo de CRUD más funcionales que estéticos serían suficientes para un BackOffice MVP, 
////      o primera versión de la entrega del proyecto, posiblemente un prototipo funcional. 
//// Su objetivo principal sería testear la funcionalidad y tener feed-back del usuario, 
////      posiblemente comenzar a configurar tablas maestras si hubiera urgencia. 

//// Vamos a ver em este tema cómo trabajamos con las View para maquetarlo 
////    con un aspecto visual mejorado y avanzado
//// Recordar que desde el Controller llamamos a las View que podrán estar compuestas por (HTML + CSS + JS)

//// Comenzamos pues a trabajar mejorando la presentación  

// Hemos visto cómo pasar datos a una View desde un Controller app>Http>Controllers>PostControllerCRUD.php
// Por ejemplo, la llamada a la View post.show le pasamos el 'post'=>$postCRUD
// Aquí se ve la "magia" de Laravel, puesto que obtiene el Model Post cuya PK es {postCRUD}

    public function show(Post $postCRUD)
    {
        return view('post.show',['post' => $postCRUD]);  // El nombre del parámetro en la llamada es postCRUD/{postCRUD}  
    }

// Podemos mejorar la llamada a la View añadiendo un 'with' 
//      para pasar a la View info puntual y concreta (no para pasar arrays, collections, etc.)
// En el store() del Controller podemos añadir el 'with' en el return back() de la siguiente manera:
//      se muestra un ejemplo para Post y un ejemplo para Category

        return back()->with('status', 'Publicación creada correctamente'); // Vuelve a la página anterior con un mensaje informativo
        return back()->with('status', 'Categoría creada correctamente'); // Vuelve a la página anterior con un mensaje informativo

// Recordar que, como hacemos un back(), nos devolvería a la View llamante que es la
// 
//      resources>view>post>create.blade.php y donde deberíamos leer este with()
//      resources>view>category>create.blade.php y donde deberíamos leer este with()

// En la View create.blade.php podemos añadir un control para mostrar este 'status', 
//      se añadade un control porque no tendremos este mensaje en la 1a llamada al formulario 
//      y puede que sí en las siguientes
// En create.blade.php añadir el código entre el @if ($errors->any()) y el 
//      <form action="{{ route('postCRUD.store') }}" method="post">
//      <form action="{{ route('categoryCRUD.store') }}" method="post">

    <!-- Comprobamos si tenemos que mostrar un mensaje de status -->
    @if (session('status'))
        <div class="alert alert-primary role='alert'">
            {{ session('status') }}
        </div>
    @endif

// Probarlo, creando algunas publicaciones y categorías
http://blog-app.test/postCRUD/create
http://blog-app.test/categoryCRUD/create


// Ejercicio; en el destroy() podemos hacer algo similar 
//      ahora mismo, no tenemos ningún mensaje de confirmación de borrado

        $postCRUD->delete(); 
	    return back()->with('status', 'Publicación eliminada correctamente'); // Vuelve a la página llamante con un mensaje 

        $categoryCRUD->delete(); 
        return back()->with('status','Categoría eliminada correctamente'); // Vuelve a página llamante con un mensaje 

// Y añadir el mismo control de mostrar mensaje 'status' en la View index.blade.php
//	    recordar que el destroy() se llama desde la View index.blade.php 

// En resources>views>post>index.blade.php
// En resources>views>category>index.blade.php

    <!-- Comprobamos si tenemos que mostrar un mensaje de status -->
    @if (session('status'))
        <div class="alert alert-primary role='alert'">
            {{ session('status') }}
        </div>
    @endif

// Probarlo eliminando alguna publicación y categoría desde 
http://blog-app.test/postCRUD
http://blog-app.test/categoryCRUD


// Ejercicio; en store() hacer lo mismo pero 'saltar' a index()
// Esta redirección permite cear un elemento (publicación, categoría, etc.) 
//      y 'saltar' al index() para mostrar todos los elementos con un mensaje. 

        $post->save();  // Guarda el registro en la DDBB
        return redirect()->route('postCRUD.index')->with('status','Publicación creada correctamente'); 

        $category->save();  // Guarda el registro en la DDBB
        return redirect()->route('categoryCRUD.index')->with('status','Categoría creada correctamente'); 

// Probarlo 

http://blog-app.test/postCRUD/create
http://blog-app.test/categoryCRUD/create 


// Y ahora se podría borrar el control de la View create.blade.php 
//      puesto que el store() 'salta' a la index.blade.php
// En general, podemos redireccionar según nos convenga

// La visto es una manera muy sencilla de devolver una información puntual a una View

//// Todo Lo visto hasta ahora sería la primera versión de una entrega para un Backoffice, 
////      es 100% funcional aunque cuida mínimamente la presentación.
//// Con esta versión ya se podría salir a producción, sería un MVP (Minium Valuable Product) 
////    para que los usuarios de backoffice pudieran comenzar a configurar los datos básicos
//// Es un CRUD que atiende más a la funcionalidad que a la presentación, 
////    por ejemplo, falta un Menú para las opciones (hay que teclear algunas) 

//// Entramos de lleno en las posibilidades de presentación de Laravel
////    mediante el motor de plantillas BLADE

//////////////// MOTOR DE PLANTILLAS BLADE
(https://laravel.com/docs/11.x/blade#main-content)

// Recordar que en resources>views> tenemos las View de la presentación; 
//      las presentaciones con código HTML + CSS + JS
// El Motor de Plantillas BLADE nos da una serie de herramientas para mejorar las View

// Hasta ahora, hemos visto que en las View, para mostrar datos, los ubicamos entre {{ }}
// Ejemplo: de la index.blade.php de publicaciones 

                <td>{{ $post->id }}</td>
                <td>{{ $post->title }}</td>
                <td>{{ $post->posted }}</td>
                <td>{{ $post->content }}</td>
                <td>{{ $post->created_at }}</td>
                <td>{{ $post->updated_at }}</td>

// Dentro de los {{ }} podemos incluir cualquier función() php 
// Por ejemplo, probar este código dentro de index.blade.php
// Vemos que muestra el time en milisegundos y un json de la estructura. 
// Se puede usar para meterlo en una variable JS y poder utilizar en JS

    <div>
        <span>{{time()}}</span>
        <span>{{json_encode($posts)}}</span> 
    </div>

    <div>
        <span>{{time()}}</span>
        <span>{{json_encode($categories)}}</span> 
    </div>

http://<example-app.test>/postCRUD
http://blog-app.test/categoryCRUD

// Añadir el código de ejemplo siguiente (Comprobarlo sacando la console del navegador)
// Tambien es ok para depuración, dejar el script y así lo podemos consultar en cualquier momento
// Se podría manipular a nivel de JS
// En index.blade.php añadir lo siguiente: 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Index Posts</title>
   
    <!-- Mostramos estructura en formato Json vía consola para debug -->
    <script>
        var app = @json($posts);
        console.log(app); 
    </script>
</head>

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Category</title>

    <!-- Mostramos estructura en formato Json vía consola para debug -->
    <script>
        var app = @json($categories);
        console.log(app); 
    </script>
</head>

http://example-app.test/postCRUD
http://blog-app.test/categoryCRUD

// y comprobarlo sacando la console del navegador
// Comentarlo todo lo anterior y dejarlo como estaba
//      o dejar el <script> de salida por consola para un futuro debug
//      es una manera de substituir el dd($posts) que aboarta la ejecución


// En BLADE, para mostrar datos, siempre parsea mediante 'htmlspecialchars' de PHP para evitar ataques XSS 
// Por ejemplo; modificar lo siguiente en return() de la función store()

return redirect()->route('postCRUD.index')->with('status','<h1>Publicación creada correctamente</h1>'); 
return redirect()->route('categoryCRUD.index')->with('status','<h1>Categoría creada correctamente</h1>'); /

http://example-app.test/postCRUD/create
http://blog-app.test/categoryCRUD/create

// Veremos que, en ambos casos, muestra el <h1>, no lo interpreta
//      observando el código html veremos que  &lt;h1&gt;Publicación creada correctamente&lt;/h1&gt;

// Si queremos que, en lugar de mostrarse se interprete, hay que substituir {{ }}, 
//      y hay que indicarlo mediante {!! !!}
// Ir al index.blade.php y modificar lo siguiente 

    <!-- Comprobamos si tenemos que mostrar un mensaje de status -->
    <!-- el if es necesario puesto que la primera vez no tendremos status -->
    @if (session('status'))
        <div class="alert alert-primary role='alert'">
            {!! session('status') !!}
        </div>
    @endif


http://example-app.test/postCRUD/create
http://blog-app.test/categoryCRUD/create

// Y ahora renderiza el mensaje en <h1>, en lugar de mostrar el tag <h1>

// Obviamente, no se recomienda esto para renderizar la info aportada por el usuario (ataques XSS)
// Ejemplo: imaginad que en el textarea de las publicaciones alguien inserta el código 
//      <script>alert("HOLA")</script>, 
//      el htmlspecialchars lo evita, no lo interpreta
//      para interpretarlo habría que añadir el {!! !!}
// Probar lo anterior intentado un ataque XSS, 
//      observamos que el content muestra el código y no lo interpreta  
//      porque tenemos un <td>{{ $post->content }}</td>

// Inciso: Podemos usar una directiva de entorno para las view, 
//      para determinar si estamos en local, producción, test, etc.
// @env('local') @endenv
// @env(['staging','production']) @endev

/////////  Código en BLADE ()

// Ojo, no abusar, tener en cuenta que es código para maquetación y control de Views
//      en absoluto se debería usar para código de negocio, que debe estar en los Controller
// Código en Views es recomendado para temas informativos o de diseño (CSS), no para control de programación
// Ejemplo, qué info mostrar sería en Controller, cómo mostrar sería en View 

// Veamos como aplicar condicionales en las View:
// para condicionales @if @else @elseif @endif
// @isset @endiseet @empty @endempty

// El switch:
// @switch($i)
// @case(1)
//      <!-- Primer cas -->
//      @break
// @case(2)
// 	    <!-- Segon cas -->
// 	    @break
// @default
//	    <!-- Cas per defecte -->
// @endswitch	

// El for / foreach / forelse / while:
//@for ($i = 0; $i < 10; $i++)
//      <li>The current value is {{ $i }}</li>
//@endfor

//@foreach ($users as $user)
//      <p>This is user {{ $user->id }}</p>
//@endforeach

// Características de los bucles: 
//@while (true)
//	    <p>I'm looping forever.</p>
//@endwhile

// Ejemplo de iteración:
// En resources>views>post>index.blade.php añadir el siguiente código al inicio, y probarlo 

@for ($i = 0; $i < 10; $i++)
	<li>The current value is {{ $i }}</li>
@endfor
http://example-app.test/postCRUD


// Forelse: 
//      Es un caso especial, si hay usuarios los muestra, en caso contrario muestra una alternativa
//@forelse ($users as $user) 
//	    <li>{{ $user->name }}</li>
//@empty
//	    <p>No users</p>
//@endforelse

// Obviamente también está el @continue @break
// @foreach ($users as $user)
//    @if ($user->type == 1)
//        @continue
//    @endif
// 
//    <li>{{ $user->name }}</li>
// 
//    @if ($user->number == 5)
//        @break
//    @endif
// @endforeach

// Por defecto, en los bucles, hay una variable $loop que se puede consultar. 

$loop->index L'índex de la iteració del cicle actual (comença a 0).
$loop->iteration La iteració del cicle actual (comença a 1).
$loop->remaining Les iteracions que queden al cicle.
$loop->count El nombre total d'elements de la matriu que s'iteren.
$loop->first Si aquesta és la primera iteració a través del cicle.
$loop->last Si aquesta és la darrera iteració del cicle.
$loop->even Si és una iteració parell a través del cicle ($loop->odd/even nos permitiría pintar en formato zebra) 
$loop->odd Si és una iteració senar a través del cicle ($loop->odd/even nos permitiría pintar en formato zebra)
$loop->depth El nivell de nidament del bucle actual.
$loop->parent Quan està en un bucle dins un altre bucle, la variable del bucle principal.

// Hacemos un ejemplo en la index.blade.php 
// Vamos a enumerar las publicaciones y las categorías, 
//	    y así no tenemos que mostrar el 'id' ya que no tiene por qué ser consecutivo
  
    <table border='1'>
        @foreach ($posts as $post)
            <tr>
                <td>{{ $post->id }} -- {{ $loop->index }}</td>
                <td>{{ $post->title }}</td>
                <td>{{ $post->posted }}</td>
                ... 
            </tr>
        @endforeach
    </table>

 <table border='1'>
        @foreach ($categories as $category)
            <tr>
                <td>{{ $categroy->id }} -- {{ $loop->index }}</td>
                <td>{{ $category->title }}</td>
                <td>{{ $category->url_clean }}</td>
                ... 
            </tr>
        @endforeach
</table>


http://blog-app.test/postCRUD
http://blog-app.test/categoryCRUD



///////////////////////////////////////////////////////////////////  COMPONENTES

//////////////// ANONYMOUS COMPONENTS

// Ejemplo de Component (Elementos de View rehusables)
// A nivel de diseño los errores siempre deberían ser iguales, 
//      el código de visualización de error siempre debería ser igual
// 	    errores con mismo diseño independientemente del error, 
//      así el usario sabrá identificar que hay error / warning. 
// Entonces, podemos extraer el código de errores del create.blade.php 
//      y ubicarlo en un apartado externo y llamarlo; será un ANONYMOUS COMPONENT
// Un Componente nos permite tener elementos estandard 
//      para poder mantenerlos de manera centralizada y reutilizarlos 
//      (spoiler: Layout con Header / Footer de todas las páginas) 
// Vamos a crear un código reutilizable para las plantillas que ya tenemos del CRUD, 
//  creamos un ANONYMOUS COMPONENT

// Recordar el sistema de errores que tenemos ahora del create.blade.php de Post, Category, etc.
// @if ($errors->any())
//      <div class="alert alert-danger">
//          <ul>
//              @foreach ($errors->all() as $error)
//                  <li>{{ $error }}</li>
//              @endforeach
//          </ul>
//      </div>
//@endif

// Para extraerlo, en resources>view>components crear un fichero alert.blade.php 
//      resources>view>components>alert.blade.php
// Extraer el código de errores del create.blade.php e insertarlo en este nuevo fichero
//      quedaría así 

@if ($errors->any())
      <div class="alert alert-danger">
          <ul>
              @foreach ($errors->all() as $error)
                  <li>{{ $error }}</li>
              @endforeach
          </ul>
      </div>
@endif

// Y en el create.blade.php (de Posts y Category), donde había el código original, 
//      codificar una llamada para incluir el código extraído 
// Desde ambas View (Post y Category) se llamara al mismo Component 

    @include('components.alert') <!-- Muestra la lista de errores -->

// Probar que desde la View se llama al nuevo Component
//      por ejemplo, pulsar el botón "Crear" dejándo todo el form en blanco 

http://<example-app.test>/postCRUD/create
http://<blog-app.test>/categoryCRUD/create

// Ejercicio, aplicar la misma estrategia al edit.blade.php de Category y Post
http://<blog-app.test>/postCRUD/2/edit
http://<blog-app.test>/categoryCRUD/2/edit

// Ahora haremos un refinamiento importante: 

// Creamos un nuevo ANONYMOUS COMPONENT denominado card-posts.blade.php y card-categories.blade.php
// En la View de index.blade.php, para cada publicación y categoría, mostrarlo aplicando este Anonymous Component
//	    es una manera de reutilizar código de maquetación
// 	    es una manera muy sencilla de crear un Card (o maquetación tipo tarjeta) para cada elemento
// En general, cuando tengamos que mostrar una lista de elementos, es buena estrategia crear un componente con 
//	    código para mostrar los distintos elementos en modo Card (tarjeta) y reutilizarlo.
// Para iterar y llamarlo, aplicaremos lo siguiente:
//      @each('components.cards-posts', $posts, 'post')
//      @each('components.cards-categories', $categories, 'category')

// Vamos a hacerlo paso a paso (es un buen ejemplo de Anonymous Component)

// Crear las siguientes subvistas en 
//      components>card-posts.blade.php
//	    components>card-categories.blade.php
// Es una maquetación estándard que muestra la información de (posts / categories / etc.) 
// 	    esta maquetación se puede alterar a voluntad según preferencias de cada uno
//      (Ojo, no para BaleArt porque la maquetación del BackOffice es impuesta por motivos de tiempo y presupuesto)
// No obstante, a nivel de Backoffice, se recomienda no esmerarse mucho en las presentaciones, 
//	    se pretende un desarrollo rápido mediante pantallas funcionales, que suelen ser de uso interno. 

// Para Posts en card-posts.blade.php

<div class="block rounded-lg bg-white shadow-secondary-1">
    <div class="p-6 text-surface">
        <h5 class="mb-2 text-xl font-medium leading-tight">{{ $post->title }}</h5>
        <h3 class="mb-2 text-xl font-medium leading-tight">{{ $post->url_clean }}</h3>
        <p class="mb-4 text-base">{{ $post->content }}</p>
        <p class="mb-4 text-sm">posted: {{ $post->posted }}</p>
        <p class="mb-4 text-sm">created at: {{ $post->created_at }}</p>
        <p class="mb-4 text-sm">updated at: {{ $post->created_at }}</p>
        <a href="{{route('postCRUD.show' , ['postCRUD' => $post->id])}}" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Show</a>
        <a href="{{route('postCRUD.edit' , ['postCRUD' => $post->id ])}}" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Edit</a>
        <form action="{{route('postCRUD.destroy' , ['postCRUD' => $post->id ])}}" method="POST" class="float-right">
           @method('DELETE')
           @csrf
           <button type="submit" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded" >Delete</button>
        </form>
    </div>
</div>

// Para Categories en card-categories.blade.php

<div class="block rounded-lg bg-white shadow-secondary-1">
    <div class="p-6 text-surface " >
        <h5 class="mb-2 text-xl font-medium leading-tight">{{ $category->title }}</h5>
        <h3 class="mb-2 text-xl font-medium leading-tight">{{ $category->url_clean }}</h3>
        <p class="mb-4 text-sm">created at: {{ $category->created_at }}</p>
        <p class="mb-4 text-sm">updated at: {{ $category->created_at }}</p>
        <a href="{{route('categoryCRUD.show' , ['categoryCRUD' => $category->id])}}" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Show</a>
        <a href="{{route('categoryCRUD.edit' , ['categoryCRUD' => $category->id])}}" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Edit</a>
        <form action="{{route('categoryCRUD.destroy' , ['categoryCRUD' => $category->id ])}}" method="POST" class="float-right">
           @method('DELETE')
           @csrf
           <button type="submit" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded" >Delete</button>
        </form>
    </div>
</div>

// Y en el index.blade.php de Post y Category substituir el código HTML de la tabla (toda la tabla) 
//      que hay por lo siguiente: (realmente, estas líneas de código sería lo único que nos debería quedar en index)

    <!-- Se muestran los elementos en forma de Card -->
    <div class="row row-cols-1 row-cols-md-3 g-4 ">
        @each('components.card-posts',$posts,'post');
    </div>

    <!-- Se muestran los elementos en forma de Card -->
    <div class="row row-cols-1 row-cols-md-3 g-4 ">
        @each('components.card-categories',$categories,'category');
    </div>

// Probarlo llamando a 
http://blog-app.test/postCRUD
http://blog-app.test/categoryCRUD

// Observación de la doc en https://laravel.com/docs/11.x/blade#loops
    @each('view.name', $jobs, 'job')
    @each('view.name', $jobs, 'job', 'view.empty')
    The @each directive's first argument is the View to render for each element in the array or collection. 
    The second argument is the array or collection you wish to iterate over
    The third argument is the variable name that will be assigned to the current iteration within the view. 
    You may also pass a fourth argument to the @each directive. This argument determines the view that will be rendered if the given array is empty.

**********************************************  (PROBLEMAS DE APLICACIÓN DE TAILWINDCSS) 

// Si en la renderización de las tarjeta no se aplica el Tailwindcss

// Laravel NO aplica Tailwindcss de namer nativa
//      la aplicación del Tailwindcss se debe "forzar" en el caso de generar nosotros las páginas HMTL 
//      como es el caso, y es lo hemos hecho hasta ahora. 
// El Breeze (Starter Kit) usa Tailwindcss e incluye los links a Tailwindcss 
// Cuando usemos el Layout que genera el Breeze, indirectamente, tendremos los links a Tailwindcss
//      pero ahora mismo, estamos en una estadio del proyecto en el que todavía no usamos los Layout de Breeze
//      ni siquiera sabemos usar Layouts 
//
// Por tanto, ahora mismo, hay que incuir los enlaces a las librerías de Tailwindcss en el HTML que estamos generando
//      se hará de la siguiente manera; añadiendo lo siguiente en el <head> del HTML  
//      @vite(['resources/css/app.css', 'resources/js/app.js'])
// Ejemplo:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Index Category</title>

    <!-- Scripts -->
    @vite(['resources/css/app.css', 'resources/js/app.js'])
</head>


// El script debería generar los siguientes enlaces
//  (verlo en código fuente HTML)

    <!-- Scripts -->
    <link rel="preload" as="style" href="http://blog-app.test/build/assets/app-BFVlPjrh.css" />
    <link rel="modulepreload" href="http://blog-app.test/build/assets/app-Cy98PJ2n.js" />
    <link rel="stylesheet" href="http://blog-app.test/build/assets/app-BFVlPjrh.css" />
    <script type="module" src="http://blog-app.test/build/assets/app-Cy98PJ2n.js"></script>    

// Por último, recordar que Tailwindcss necesita una parseo y generación de clases 
//  esto se consigue de dos maneras: 

λ npm run build (para generar el fichero css final con las clases de Tailwind)
λ npm run dev (para rastrear en real-time y generar el fichero css con las clases de Tailwindcss)

**********************************************  (FIN PROBLEMAS DE APLICACIÓN DE TAILWINDCSS) 


// La directiva @each es muy interesante porque nos proporciona un listado, un volcado completo,  
// Obervar que en index.blade, bien hecho, nos quedaría una única linea en el <body> gracias a la directiva @each()
// Observar que en la Card hemos añadido 2 nuevos enlaces; el de 'postCRUD.show' y 'postCRUD.edit' 
//      además del 'postCRUD.destroy' (que ya teníamos antes) 
// El enlace DELETE recordar que hay que cambiar el method, el resto no hace falta, es el correcto. 
// Probarlo todo; obtener el index de Categories y de Posts, y seleccionar algunos para ejecutar el show(), edit(), destroy(), etc.


// Volvemos al Controller PostControllerCRUD.php y CategoryControllerCRUD
// Recordar que en el index() hay una función all()

    $posts = Post::all(); // Obtención de todos las publicaciones. 
    return view('post.index',['posts' => $posts]); 

    $categories = Category::all(); // Obtener todos los registros
    return view('category.index',['categories' => $categories]); // Los mostramos con la View 

// Si tenemos una gran cantidad de registros, el all() puede ser problemático. 
//	    nos hará un volcado masivo de información y puede saturar la pantalla
// Laravel proporciona el paginate() que es una paginación automática
// en el método index() del PostControllerCRUD y CategoryControllerCRUD cambiar el all() por:

        $posts = Post::paginate(3); // Devuelve el resultado de 3 en 3 publicaciones

        $categories = Category::paginate(3); // Devuelve el resultado de 3 en 3

http://example-app.test/postCRUD
http://blog-app.test/categoryCRUD

//  Probarlo ahora con un dd($posts) o mirando la consola (si no borramos esa opción)
//	    para indagar el contenido de posts o categories
// 	Observar que contienen información para poder construir la paginación

$posts = Post::paginate(3);
dd($posts); 
return view('post.index',['posts' => $posts]);

  #items: 
Illuminate\Database\Eloquent

Collection {#1308 ▶}
  #perPage: 3
  #currentPage: 1
  #path: "http://example-app.test/postCRUD"
  #query: []
  #fragment: null
  #pageName: "page"
  +onEachSide: 3
  #options: array:2 [▶]
  #total: 11
  #lastPage: 4

// Ahora, hay que construir la paginación en el index.blade.php de Category y de Post
//	para ello, tan sencillo como añadir el siguiente código

    <!-- Se muestran los elementos en forma de Card -->
    <div class="row row-cols-1 row-cols-md-3 g-4 ">
        @each('components.card-posts',$posts,'post');
        {{ $posts->links() }} <!-- Paginación -->
    </div>

    <!-- Se muestran los elementos en forma de Card -->
    <div class="row row-cols-1 row-cols-md-3 g-4 ">
        @each('components.card-categories',$categories,'category');
        {{ $categories->links() }} <!-- Paginación -->
    </div>

http://example-app.test/postCRUD
http://blog-app.test/categoryCRUD

// Podemos comprobar que ha generado automáticamente los enlaces de Prev y Next junto con la info de la páginación
Showing 7 to 9 of 11 results « Previous Next »

// La paginación también se puede controlar manualmente porque tenemos información para ello
//      como hemos visto en el dd($posts), pero de entrada, Laravel nos proporciona esta herramienta
// Observación, se pueden cambiar los textos con el sistema multiidioma (no está por defecto)  


// También se puede crear componentes más sofisticados, que tienen como base una Class 
//      para poder pasar info adicional, esto nos da mucha más flexibilidad.
// Los COMPONENTES ANONIMOS (Anonymous Components) 
//      están en resources>views>components>xxx.blade.php y son los componentes que hemos creado hasta ahora

********************************************************************************
*******************  aquí para Lunes 3 Febrero *********************************
*******************************************************************************

//////////////// CLASS BASED COMPONENTS

// Vemos COMPONENTES BASADOS EN UNA CLASS (Class Based Components)
//      y estos ya se crean con la terminal, y generan 2 ficheros
//      creamos uno:

λ php artisan make:component messages

   INFO  Component [C:\laragon\www\blog-app\app\View\Components\messages.php] created successfully.
   INFO  View [C:\laragon\www\blog-app\resources\views\components/messages.blade.php] created successfully.

// Comprobarlo en: 
app\View\Components\messages.php // Es un Componente con el código estándard de Component
resources\views\components/messages.blade.php // Es una View vacía; con el mensaje del día


// Modificamos la View vacía que ha generado en resources>views>components>messages.blade.php de la siguiente manera
<div class="alert alert-primary">
    <h1 class="alert-heading" >¡Primary! Este es el título</h1>
    <p>Este es un aviso primary. Puedes poner tantas líneas necesites.</p>
</div>

// Como hemos creado un Component, lo podemos llamar de varias maneras
//	aunque algún tipo llamada está restringido a Class Based Components (creados con el make) 
//	una manera:     
//		@component('components.messages') @endcomponent
//	otra manera: 
//		<x-messages />
// Vamos al index.blade.php del post y categories (resources>views>post>index.blade.php) y añadir código:

// En Post 
     <!-- Llamada a un class component -->
    @component('components.messages') 
    @endcomponent

    <!-- Se muestran los elementos en forma de Card -->
    <div class="row row-cols-1 row-cols-md-3 g-4 ">
        @each('components.card-posts',$posts,'post');
        {{ $posts->links() }} <!-- Paginación -->
    </div>

// En Category
     <!-- Llamada a un class component -->
    @component('components.messages') 
    @endcomponent
    
    <!-- Se muestran los elementos en forma de Card mediante Componente Anónimo -->
    <div class="row row-cols-1 row-cols-md-3 g-4 ">
        @each('components.card-categories',$categories,'category');
        {{ $categories->links() }} <!-- Paginación -->
    </div>

http://example-app.test/postCRUD
http://blog-app.test/categoryCRUD


// Otra manera de llamar al Component es como sigue:
//	comentar la llamada anterior y codificar así

    <!-- Llamamos a un componente -->
    <!-- @component('components.messages') -->
    <!-- @endcomponent -->
    <x-messages />

http://example-app.test/postCRUD


// Puede ser muy útil, porque tenemos el control de Component y podemos poner el código que deseemos
// El make:component crea un Class Based Components (class messages extends Component{...})
// Los ANONYMOUS COMPONENT los podemos crear directamente, sin el make:component. 
// En un CLASS BASED COMPONENT se crean con el terminal y podemos procesar los datos recibidos.

// Ahora que hemos construído un Class Based Component, que son dinámicos veamos cómo pasarle valores 
//  y tratar el valor en el Componente
// Por ejemplo: 
// Llamada a un Class Based Component con :
//
//	<x-messages type="danger"/>
// 
//	@component('components.messages',['type' => 'danger'])
//	@endcomponent
//	
// Y en el constructor del Class Based Component, obtener el valor en public function __construct(public string $type)
// 	luego, en el código de la plantilla o render lo modificaremos para tratar el valor
//
//	<div class="alert alert-{{$type}}">

// Veámolo todo, y la llamada de las 2 formas

// En app>View>Components>messages.php 
//	modificar el constructor de la siguiente manera:

    public function __construct(public string $type)
    {
        //
    }

// En resources>view>post>index.blade.php
//	llamar al Component con este nuevo valor
//	mostramos las 2 maneras:

    <!-- Llamamos a un componente -->
    <x-messages type="danger"/>

    <!-- Llamamos a un componente -->
    @component('components.messages',['type' => 'danger'])
    @endcomponent

// Finalmente, en resources>views>components>messages.blade.php
//	modificar la View para que renderize según el parámetro
//  public function __construct(public string $type)

<div class="alert alert-{{$type}}">
    <h1 class="alert-heading" >¡{{$type}}! Este es el título</h1>
    <p>Este es un aviso primary. Puedes poner tantas líneas necesites.</p>
</div>

http://example-app.test/postCRUD
http://blog-app.test/categoryCRUD    


// Ojo, si da un error, es porque no comenta bien las llamdas anteriores
//	borrar el 
//	<!-- Llamada a un class component -->
//	<!-- @component('components.messages') -->
//	<!-- @endcomponent -->

// Y aquí se plantea un problema con las librerías CSS
//	    porque debería incluir este <div class="alert alert-danger">
//	    pero como es dinámico, si fuera Tailwindcss creo que no lo incluiría. 
//	    no obstante, creo que estas alert son de Bootstrap

//// En el Motor de Plantillas Blade hay un concepto denominado 'slots'
// Podemos incluir estos 'slots' en las View, que serían partes del código html que vendrán de otro sitio 
// Ejemplo (mal hecho)
//	Si hacemos ejemplo anterior, todo dinámico, estaría obligado a pasar nuevas variables, tantas como sean necesarias
//	<div class="alert alert-{{$alertType}}">
//    		<h1 class="alert-"{{$alertHeading}}">{{$alertType}} {{$title}}</h1>
//    		<p>{{$message}}</p>
//	</div>
//	Estamos usando $alertType, $alertHeading, $title, $message, etc. 
//	y en el Constructor de la Class habría que tenerlo en cuenta y añadirlas.  

// Podemos hacerlo de otra manera, y usar el concepto de named slots <x-slot name="nombre_variable_que_paso">
//	esto evita tener que definir cada una de las variables
// Probarlo de la siguiente manera :
//	lo haremos comenzando con algo sencillo y lo vamos mejorando 

// Modificar la View de la siguiente manera

<div class="alert alert-primary">
    {{$type}}
    {{$title}}
    <p>Este es un aviso primary. Puedes poner tantas líneas necesites.</p>
</div>

// Y las llamadas serían de la siguiente manera

// En index de Post 

<x-messages type="danger">
  <x-slot name="title">
    <h1 class="alert-heading" >¡Primary! Este es el título</h1>
  </x-slot>
</x-messages>

// En index de Cateogry 

    @component('components.messages',[
        'type' => 'danger',
        'title' => '<h1 class="alert-heading">Este es el título</h1>',
        ]) 
    @endcomponent 

// Y teníamos definido el $type en el Constructor, pero no ha hecho falta definir el $title
//	porque lo hemos indicado como <x-slot name=""> y lo hemos podido usar en la View

// Entonces, la renderización de la View es totalmente configurable
//	por ejemplo, en la llamada del index podemos cambiarlo por
//	(añadirlo para que haga dos llamadas)

    <x-messages type="warning">
        <x-slot name="title">
          <h2>Esto es una alerta</h2>
        </x-slot>
    </x-messages>

// Podemos redondearlo de la siguiente manera
// 	modificar la View añadiendo un slot 

<!-- Utilizamos el concepto de Slot -->
<div class="alert alert-primary">
    {{$type}}
    {{$title}}
    <div style="background-color:blue; color:chartreuse">
        <p>{{slot}}</p>
    </div>    
</div>

// En {{slot}} pondrá todo aquello que no esté "bautizado", es decir, que no sea un named slot
//	Probarlo llamadolo de la siguiente manera

    <x-messages type="warning">
        <x-slot name="title">
          <h2>Esto es una alerta</h2>
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot en el componente
    </x-messages>

// De esta manera en <x-messages> puedo incluir el código que desee que aparezca en la plantilla
// 	por ejemplo, solo en caso de "danger" hacer un padding
//	queda como sigue: 

    <x-messages type="danger">
        <x-slot name="title">
          <h1 class="alert-heading" >Este es el título</h1>
        </x-slot>
        <div style="padding: 40px">
            Este texto lo mostrará donde haya puesto el slot en el componente,puedo menter lo que quiera
        </div>
    </x-messages>

    <x-messages type="warning">
        <x-slot name="title">
          <h2>Esto es una alerta</h2>
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot en el componente
    </x-messages>

// y para el caso de la llamada de Category, con la otra forma de llamarlo

    <!-- Llamamos a un componente -->
    @component('components.messages',['type' => 'warning'])
        @slot('title','Esto es una alerta')
        @slot('slot','Este texto lo mostrará donde haya puesto el slot en el componente')
    @endcomponent 

// En resumen, en los Class Based Component se pueden definir tantos $slot como se necesiten
// 	se identifican con el name, en el ejemplo, tenemos name="title"
//	si no están nombrados, es el $slot general 

// Observar que ahora mismo tenemos un variable "type" en el Constructor, named slots "title", y el slot general 
//	revisarlo tranquilamente, no es tan difícil de entender

// En este momento, tenemos dos Componente (Anonymous Component y Component Class Based) funcionando 
//	refinamos el Anonymous Component

// Podemos añadir atributos nuevos, nos referimos a atributos de tags html
// por ejemplo, podríamos escribir algo así:
// 	<x-alert alert-type="danger" class="m-4" > 
// 	Y Laravel nos proporciona una variable para poder recuperar estos atributos html 
// 	<div class="alert alert-{{$alertType}} {{$attributes['class']}}"> // Es una lista de attributes y acceder a la Class 
// 	<div {{$attributes->merge(['class' => 'alert alert-primary'])}}">

// Veamos un ejemplo de esto:
// En index.blade.php añadir el attribute style="background-color: coral" como sigue:

// Original
    <x-messages type="danger">
        <x-slot name="title">
          <h1 class="alert-heading" >Este es el título</h1>
        </x-slot>
        <div style="padding: 40px">
            Este texto lo mostrará donde haya puesto el slot en el componente,puedo menter lo que quiera
        </div>
    </x-messages>

// Nuevo
    <x-messages type="danger" style="background-color: coral">
        <x-slot name="title">
          <h1 class="alert-heading" >Este es el título</h1>
        </x-slot>
        <div style="padding: 40px">
            Este texto lo mostrará donde haya puesto el slot en el componente,puedo menter lo que quiera
        </div>
    </x-messages>

// Y luego en message.blade.php, modificarlo para extraer y usar el attribute 'style' que acabamos de crear:
//	se usa {{$attributes}}
<div class="alert alert-primary">
    {{$attributes}}
    {{$type}}
    {{$title}}
    <div style="background-color:blue; color:chartreuse ">
            {{$slot}}
    </div>
</div>

http://example-app.test/postCRUD

// Pero, lo muestra, tal cual, y lo que queremos es que actúe como attribute del código html, modificar:
<div class="alert alert-primary">
    {{$attributes["style"]}}
    {{$type}}
    {{$title}}
    <div style="background-color:blue; color:chartreuse ">
            {{$slot}}
    </div>
</div>
http://example-app.test/postCRUD

// Y últimas modificaciones finales para que ya actue todo correctamente 
// 	queda como sigue:

<!-- Utilizamos un slot -->
<div class="alert alert-{{$type}}" style="{{$attributes["style"]}}">
    {{$title}}
    <div style="background-color:blue; color:chartreuse ">
            {{$slot}}
    </div>
</div>

<!-- Utilizamos el concepto de Named Slot -->
<div class="alert alert-{{$type}}" style="{{$attributes["style"]}}">
    {{$title}}
    <div style="background-color:blue; color:chartreuse">
        <p>{{$slot}}</p>
    </div>    
</div>


// Y en las llamadas, lo modificamos levemente

    <x-messages type="danger" style="background-color: coral">
        <x-slot name="title">
          <h1 class="alert-heading" >Este es el título</h1>
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot genérico en el componente
    </x-messages>

    <x-messages type="warning" style="background-color: coral">
        <x-slot name="title">
            <h1 class="alert-heading">Esto es un Warning</h1>
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot en el componente
    </x-messages>

// Probarlo y comprobar que genera el siguiente código html 

<!-- Utilizamos el concepto de Named Slot -->
<div class="alert alert-danger" style="background-color: coral">
    <h1 class="alert-heading" >Este es el título</h1>
    <div style="background-color:blue; color:chartreuse">
        <p>Este texto lo mostrará donde haya puesto el slot genérico en el componente</p>
    </div>    
</div>

<!-- Utilizamos el concepto de Named Slot -->
<div class="alert alert-warning" style="background-color: coral">
    <h1 class="alert-heading">Esto es un Warning</h1>
    <div style="background-color:blue; color:chartreuse">
        <p>Este texto lo mostrará donde haya puesto el slot en el componente</p>
    </div>    
</div>   

// El ejemplo de Category en este momento, no está actualizado con esta modificación del componente
//	y generará un error. 
// Cambiar la llamada por las llamadas de tipo <x-messages..> al estilo Post

// Y todo esto significa, que tenemos el control desde el index.blade.php para modificar casi lo que quiera
// Incluso puedo hacer (no se ha probado) un 'merge' para concatenar estilos
// 	<div {{$attributes->merge(['class' => 'alert alert-primary'])}}">



// Podemos usar variables para pasar valores a los componentes
// 	se puede hacer de dos maneras
//	una vez definida la variable @php $variable = 'valor'; @endphp
//	se puede usar como type="{{$variables}}"
//	o se puede usar como :type="$variables"
// Ejemplo:

// Cambiar las llamada de la siguiente manera

    @php
        $error = 'danger';
    @endphp

    <x-messages type="{{$error}}" style="background-color: coral">
        <x-slot name="title">
          <h1 class="alert-heading" >Este es el título</h1>
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot genérico en el componente
    </x-messages>

    @php
        $error = 'danger';
    @endphp

    <x-messages :type="$error" style="background-color: coral">
        <x-slot name="title">
            <h1 class="alert-heading">Esto es un Warning</h1>
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot en el componente
    </x-messages>

http://example-app.test/postCRUD


// Los visto sirve para extraer información de mensajes que vienen del propio PHP 


/////// Vamos a ver más cosas sobre plantillas Blade 
// Una de las grandes ventajas de utilizar las Class Based Componet
// 	es que podemos crear métodos en la Class de las Class Based Component 
//	para poderlos utilizar directamente en Blade
// Por ejemplo, creamos un método adicional en la Class

// En app>view\Components>messages.php crear un método 
    public function majuscules($v) {

        // Pasa a mayúsculas
        return strtoupper($v); 
    }

// Y en la View messages.blade.php usar este método
<!-- Utilizamos el concepto de Named Slot -->
<div class="alert alert-{{$type}}" style="{{$attributes["style"]}}">
    {{$title}}
    {{$majuscules($mayusculas)}}
    <div style="background-color:blue; color:chartreuse">
        <p>{{$slot}}</p>
    </div>    
</div>

// Y incluirlo en las llamadas al Componente

    @php
        $error = 'danger';
    @endphp

    <x-messages type="{{$error}}" style="background-color: coral">
        <x-slot name="title">
          <h1 class="alert-heading" >Este es el título</h1>
        </x-slot>
        <x-slot name="mayusculas">
            Hola que tal 
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot genérico en el componente
    </x-messages>

    @php
        $error = 'warning';
    @endphp

    <x-messages :type="$error" style="background-color: coral">
        <x-slot name="title">
            <h1 class="alert-heading">Esto es un Warning</h1>
        </x-slot>
        <x-slot name="mayusculas">
        </x-slot>
        Este texto lo mostrará donde haya puesto el slot en el componente
    </x-messages>


http://example-app.test/postCRUD
http://blog-app.test/categoryCRUD

// Y podemos crear todos los métodos que necesitemos. 
// 	Nota: strtoupper($v); es una función de PHP, 
//	podríamos haberlo usado directamente sin el método 


// Volviendo a los Anonymous Component, que son los que creamos al principio
// Recordar el Anonymous Component en resources>views>components>alert.blade.php
// Que ahora se invoca con el @include('components.alert') en create.blade.php
// 	pero se podría invoar también con <x-alert /> y aplicar mismos criterios
//	obviamente, al no ser un Class Based Componet no podemos crear métodos
// Probarlo así, comentando el include original (create.blade.php)

    <!-- Mostramos la lista de errores -->
    <!-- @include('components.alert')  -->
    <x-alert />

http://example-app.test/postCRUD/create
http://blog-app.test/categoryCRUD/create


////////////////  DYNAMIC COMPONENTS

////  Algo interesante, a nivel de estructura, pero que requiere de un buen análisis
////  Supongamos que es necesario renderizar un Component que no sabemos cuál será hasta el momento de ejecución
////  Para ello tenemos el Dynamic-Component que representa el Component en función de un valor en tiempo de ejecución

// Ejemplo: 
// 	Suponemos que el mensaje Success, Warning y Error tienen una estructura y renderización diferente,  
//	entonces, podemos utilizar un Dinamic-Component
// 	la invocación es mediante <x-dynamic-component :component="$componentName" > 

// Hagamos una prueba de esto con un Dynamic-Component
// Añadir este código en index.blade.php antes de los <x-messages> ya creados 

    @php
        $componentName = "messages";
    @endphp

    @php
        $error = 'success';
    @endphp

    <x-dynamic-component :component="$componentName" type="{{$error}}" style="background-color: coral">
        <x-slot name="title" >
            <h1 class="alert-heading" >Este es el título dynamic-component</h1>
        </x-slot>
        <x-slot name="mayusculas">
            Hola que tal 
        </x-slot>
        Este es un aviso success. Que viene de un dynamic-component
    </x-dynamic-component>

http://example-app.test/postCRUD


// Esta estrategira va bien cuando no sabemos qué tipo de Component necesitaremos
//      Ej: Si tenemos una web de venta de libros; se muestra la presentación del libro con un Component con resumen del libro y una foto
//      Ej: Si es otro producto, por ejemplo una revsita que no tenga foto, la presentación con un Component que solo renderiza la descripción, etc. 
// Se identifica el Component y renderiza un Dinamic-Component u otro. 

// Vamos a ver si podemos hacer otro ejemplo con el <x-dynamic-component :component="$componentName" >
// 	no es un tema trivial, hay que tenerlo bien claro para usarlo, requiere de un análisis

// Creamos el resources>views>components>success.blade.php que sea copia del alert.blade.php
//	recordar que el alert.balde.php es un Anonymous Component, por tanto, no se crea con el terminal 
// Substituimos el código por este sencillo código: 

<h1>Ha anat bé</h1>

// Ahora, en create.blade.php revisamos el código y vemos que tenemos el siguiente
// 	código de pruebas anteriores

    <!-- Mostramos la lista de errores -->
    <!-- @include('components.alert')  -->
    <x-alert />

// Lo quitamos (comentamos) y añadimos lo siguiente:
// 	    Si genera errores, quiero que carge el Component de "alert" original
// 	    Si no hay errores, quiero que me carge el nuevo Component de "success"
// Se podría mejorar, pero en create.blade.php (observación, no llamará nunca el success porque salta al index())
// queda así :

    <!-- Mostramos la lista de errores -->
    <!-- @include('components.alert')  -->
    <!-- <x-alert /> -->

    @php 
        $componentName = ''; 
        if ($errors->any()) {
            $componentName = 'alert'; 
        } else {
            $componentName = 'success'; 
        }
    @endphp 

    <x-dynamic-component :component="$componentName">
    </x-dynamic-component>

http://example-app.test/postCRUD/create


// Con lo anterior se ve la idea o el concepto de este <x-dynamic-component :component="$componentName">
// No obstante, como metodología de trabajo, es mejor hacer un único Component "menssages" y pasarle los mensajes 
// Hemos hecho ejemplo de un Dynamic Component y controlarlo de manera "dinámica" en la llamada. 


// Resumen : 
// ANONYMOUS COMPONENTS -> Adecuados para reutilizar bloques de código en Front
// CLASS BASED COMPONENTS -> Adecuados para pasar valores y renderizar según estos valores (evolución de los Anonymous Components)
// DYNAMIC COMPONENTS -> Adecuados para usar un u otro Component dependiendo de valores en ejecución (evolución de los Class Based)



///////////////////////////////////////////// LAYOUT


//// Para acabar, veremos lo que son las plantillas o LAYOUT
// La mayoría de webs mantiene un diseño similar en diferentes páginas,
//  	esto es muy común para mantener un diseño coherente a lo largo de todo el website.
// La coherencia de diseño se puede gestionar con los Layout 
// La idea es definir un solo Component Blade y después reutilizarlo en toda la web. 
// Laravel (y el Breeze) genera unos Layout por defecto en
//	 resources>views>layouts 
//	y en estos layouts es donde se incluirán las librerías generales, por ejemplo, las de Bootstrap, o las de Tailwind

// Fijarse un poco en el contenido deel app.blade.php, 
//	que sería, por decirlo de algún modo, el HTML superior, la página de más arriba
//	ver como existe el <!DOCTYPE html>, <html lang="..."> <head> 
//	en este <head> están los <meta..>, <links...>, y las librerías de Tailwindcss (incluídas por el Breeze) en @vite(...)
//	todos estos 'tag' serían los de una página 'padre' para un proyecto Laravel.
//	Si, en lugar de Tailwindcss, que lo ha añadido el Breeze, quisiéramos Bootstrap, se cambiaría aquí (o crear un layout padre nuevo y llamarlo)
//
//	en el <body> de este Layout fijarse que hay un <div class="min-h-screen bg-gray-100"> que lo incluiría todo en fondo gris
//	también el @include('layouts.navigation') que serán los menú del proyecto (luego lo usaremos para nuestro menú)
//	ver los menús de ahora en  http://blog-app.test/dashboard y revisar responsividad 
//	luego hay un @isset($header) que controla si existe un header (o parte superior de la página), y lo renderizaría 
//	Finalmente hay un <main> donde se mostrarían nuestros dato, o nuestra renderización, que usa un {{ $slot }}
//	

// Veamos un ejemplo, veamos cómo construye la página de Dashboard
//	Analizar el resources>views>dashboard.blade.php
//	llama al <x-app-layout> (que genera la página principal) 
//	luego tiene un <x-slot name="header">, que hemos visto que se puede poner o no con @isset($header)
//	y luego el <div class="py-12"> que se renderizaría en {{ $slot }} y sería nuestra parte
//
//	Hacer una prueba, eliminado (luego volverlo a poner) de dashboard.blade.php todo el tag <x-slot name="header">
//	recargar el http://blog-app.test/dashboard, y comprobar que ahora no hay cabecera. 
//
//	Observar que los literales se están escribiendo en un formato específico 
//	__('Dashboard'), __("You're logged in!")
//	está pensado para multiidioma, que funciona bajo una traducción de literales mediante "i18n" (JSON de traducción)
//	no obstante, hay que configurarlo, Laravel no lo trae por defecto. 


////////////////// APLICANDO MAQUETACIÓN DEFINITIVA ///////////////////////
///////////////// (Recordar hacer backup de ficheros actuales para tener ejemplos) 

// Vamos a pintar bonito ya, y de una vez por todas, aplicando diseño definitivo y los Layout por defecto que tenemos ahora (por defecto y Breeze)
// Para comenzar, dejaremos los fichero siguientes con solo lo necesario 
//	OJO: Copiaremos los originales para no perderlos y tener los ejemplos vistos
//	resources>view>post>index.blade.php (duplicar a) resources>view>post>index.blade_old.php
//	resources>view>category>index.blade.php (duplicar a) resources>view>category>index_old.blade.php
//	Una vez hecha las copias para guardar los ejemplos, ahora copiamos el contenido de 
//	resources>views>dashboard.blade.php a resources>view>post>index.blade.php y a resources>view>category>index.blade.php
// 	y los modificaremos levemente:
//
// 	OJO: A partir de ahora, estermos utilizando app.blade.php como página html 'padre' en la que incluiremos
//	nuestra información. Por tanto, recordar hacer login (bmesabater@gmail.com 12345678), en caso contrario puede que no funcionen las rutas 


////////// INDEX


// Para Posts en post>index.blade.php (asegurarse haber creado una copia con original en index.blade_old.php)
// Analizar un poco que hace: hay llamada llama al <x-app-layout>, tenemos un <x-slot name="header">
//  luego tenemos un <div class="py-12"> que sería el "slot"
<x-app-layout>

    <!-- Header de listado de Posts -->
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Listado de Publicaciones') }}
        </h2>
    </x-slot>

    <!-- Listado de Posts -->
    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900">

                    <!-- Se muestran los elementos en forma de Card -->
                    @each('components.card-posts',$posts,'post')
                    {{ $posts->links() }} <!-- Paginación -->

                </div>
            </div>
        </div>
    </div>

</x-app-layout>

// Para Categories en category>index.blade.php (asegurarse haber creado una copia con original en index.blade_old.php)
<x-app-layout>

        <!-- Header de listado de Categories -->
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Listado de Categorías') }}
        </h2>
    </x-slot>

        <!-- Listado de Categories -->
    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900">
                    
                    <!-- Se muestran los elementos en forma de Card -->
                    @each('components.card-categories',$categories,'category') <!-- Listado de Categorías -->
                    {{ $categories->links() }} <!-- Paginación -->

                </div>
            </div>
        </div>
    </div>
    
</x-app-layout>

// Probarlo (recordar npm run build / dev) 
http://blog-app.test/postCRUD
http://example-app.test/categoryCRUD

// Si no se ve correctamente el problema está en el Tailwindcss, debe compilarse, si no no funcionará bien. 
// Cada vez que hacemos algún cambio de CSS, el Tailwindcss debe recompilarse
// public>build>assests están los ficheros CSS generados para Tailwindcss
// Podemos generar el archivo de Class mediante el teminal

λ npm run build 

	> build
	> vite build

	vite v5.4.4 building for production...
	✓ 54 modules transformed.
	public/build/manifest.json             0.27 kB │ gzip:  0.14 kB
	public/build/assets/app-CvS0jiOV.css  39.99 kB │ gzip:  7.46 kB
	public/build/assets/app-DLXkxiZ3.js   79.44 kB │ gzip: 29.58 kB
	✓ built in 1.68s

λ npm run dev (para rastrear de manera continua, y no es optimo, usarlo durante el desarrollo y al final aplicar un build)  

// Así y todo, puede que haya problemas parab mostrar el texto (eliminar las referencias a modo dark, puede dar problemas) 

// Lo que ocurre ahora, es que en el campo content, a consecuencias del factory, hay un montón de código html metido el algunos registros. 
// Se deberían borrar o actualizar estos registros para que se muestren solamente contenido textual sin tags (No lo hacemos por ahora)
//	lo que haremos después será aplicar un editor (CKEditor) para los textarea que nos permita formatear al texto (negrita, subrayado, etc.)


// Vamos a cambiar algo, el botón DELETE en rojo de la siguiente manera 
//	en el card-posts.blade.php y en el card-categories.blade.php

// Original
<button type="submit" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded" >Delete</button

// Nuevo 
<button type="submit" class="bg-gradient-to-r from-red-100 to-red-500 hover:bg-blue-900 text-white font-bold py-2 px-4 rounded" >Delete</button>

// Y puede no funcionar porque lo tienes que volver a recompilar para que el Tailwindcss se aplique
// Cada vez que tocas algo del css hay que volver a compilar 
λ npm run build

// Esto no es práctico, por lo que tenemos el 
λ npm run dev


// Que constántemente monitoriza cambios del Blade y lo recompila 
// La DESVENTAJA, es que no genera un css minimizado, pero es muy útil durante el desarrollo
// Al final del desarrollo, cuando se considera estable, 
//	entonces aplicar el 'run build' para que genere un CSS minimizado 
// Probarlo cambiando el color del SHOW en un verde degradado sin recompilar

λ npm run dev

bg-gradient-to-r / from-green-500 / to-green-700

// Original 
 <a href="{{route('categoryCRUD.show' , ['categoryCRUD' => $category->id])}}" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Show</a>

// Nuevo 
 <a href="{{route('categoryCRUD.show' , ['categoryCRUD' => $category->id])}}" class="bg-gradient-to-r from-green-500 to-green-700 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Show</a>

// Volver a los originales, tanto del botón Delete como del botón Show, 
//  no aplicaremos degradados en el diseño final, solo colores


////////// SHOW

// Veamos ahora las otras presentaciones, vamos también a ponerlo bonito de una vez por todas
// Pulsar sobre "Show" sobre un elemento del listado, a ver cómo se muestra : Obviamente, es feo
//	y no sigue el diseño del listado, que vamos a tomar como el estándard  

//	Hacer copia del original show.blade.php (para tener los ejemplos de lo visto) 
//	resources>views>post>show.blade.php copiar a resources>views>post>show.blade_old.php
//	resources>views>category>show.blade.php copiar a resources>views>category>show.blade_old.php

// Copiamos el index.blade.php y lo empastamos en el show.blade.php 

// El show.blade.php quedaría de la siguiente manera:
// 	También he tenido que arreglar alguna cosilla, no respeta el dark (modo oscuro) 
// 	He tenido que elimiar el dark:text-gray-200 y el dark:text-gray-100 y el dark:bg-gray-800
//	Me queda así el show.blade.php:
// Observar cómo llamamos al componente  <x-card-posts :post="$post" />
// Observar cómo llamamos al componente  <x-card-categories :category="$category" />

// Para Posts 
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Show Publicación :') }} {{ $post->title  }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900">
                    <x-card-posts :post="$post" />
                </div>
            </div>
        </div>
    </div>
</x-app-layout>


// Para Category
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Show Category :') }}  {{ $category->title  }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900">
                    <x-card-categories :category="$category" />
                </div>
            </div>
        </div>
    </div>
</x-app-layout>

// Probarlo 
http://blog-app.test/postCRUD/1
http://blog-app.test/categoryCRUD/1

// El Show muestra el botón de Show, lo suyo sería crear un Component dinámico para evitar este botón
// 	para que aparezca según sea el caso. 


////////// CREATE

// Ahora pulsamos el botón Edit desde el Show o desde el listado, y se muestra feo
// Procedemos de la misma manera, primero con el Create:

//	Hacer copia del original create.blade.php para tener ejemplos de lo visto
//	resources>views>post>create.blade.php copiar a resources>views>post>create.blade_old.php
//	resources>views>category>create.blade.php copiar a resources>views>category>create.blade_old.php
//	
// Los limpiamos de todo los ejemplos que hemos hecho y queda así:

// Para Post (Ojo, observar que renderizamos el postes yes / not) 

<x-app-layout>

    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Crear una Publicación') }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900 ">
                    
                    <form action="{{ route('postCRUD.store') }}" method="post">
                        @csrf  <!-- Security Token -->

                        <div class="mb-3">
                            <label for="title">Título</label>
                            <input type="text" class="mt-1 block w-full" style="@error('title') border-color:RED; @enderror" name="title" />
                            @error('title')
                                <div>{{$message}}</div>
                            @enderror
                        </div>

                        <div class="mb-3">
                            <label for="url_clean">Url Clean</label>
                            <input type="text" class="mt-1 block w-full" style="@error('url_clean') border-color:RED; @enderror" name="url_clean" />
                            @error('url_clean')
                                <div>{{$message}}</div>
                            @enderror                  
                        </div>

                        <div class="mb-3">
                            <label for="content">Contingut</label>
                            <textarea style="@error('content') border-color:RED; @enderror" name="content" col="3" class="mt-1 block w-full"></textarea>
                            @error('content')
                                <div>{{$message}}</div>
                            @enderror
                        </div>

                        <div class="mb-3">
                            <label for="posted" class="form-label">Publicat</label>
                            <select name="posted" class="mt-1 block w-full">
                                <option value="yes">Si</option>
                                <option value="not">No</option>
                            </select>
                        </div>
                       
                        <div>
                            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Crear</button>
                        </div>
                    </form>

                </div>
            </div>
        </div>
    </div>

</x-app-layout>

// Para Category

<x-app-layout>

    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Crear una Categoria') }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900 ">
                    
                    <form action="{{ route('categoryCRUD.store') }}" method="post">
                        @csrf  <!-- Security Token -->

                        <div class="mb-3">
                            <label for="title">Título</label>
                            <input type="text" class="mt-1 block w-full" style="@error('title') border-color:RED; @enderror" name="title" />
                            @error('title')
                                <div>{{$message}}</div>
                            @enderror
                        </div>

                        <div class="mb-3">
                            <label for="url_clean">Url Clean</label>
                            <input type="text" class="mt-1 block w-full" style="@error('url_clean') border-color:RED; @enderror" name="url_clean" />
                            @error('url_clean')
                                <div>{{$message}}</div>
                            @enderror                  
                        </div>

                        <div>
                            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Crear</button>
                        </div>
                    </form>

                </div>
            </div>
        </div>
    </div>

</x-app-layout>

// Probarlo creando algún nuevo elemento con y sin errores


//////////   EDIT 

// Vamos ahora con el Edit
//	Hacer copia del original edit.blade.php para tener ejemplos de lo visto
//	resources>views>post>edit.blade.php copiar a resources>views>post>edit.blade_old.php
//	resources>views>category>edit.blade.php copiar a resources>views>category>edit.blade_old.php

// Para Post 

<x-app-layout>

    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Editar Publicación :') }}  {{ $post->title  }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900 ">

                    <form action="{{ route('postCRUD.update', ['postCRUD' => $post->id ]) }}" method="post">

                        @csrf
                        @method('PUT') 

                        <div class="mb-3">
                            <label for="title">Títol</label>
                            <input type="text" class="mt-1 block w-full" style="@error('title') border-color:RED; @enderror" value="{{ $post->title }}" name="title" />
                            @error('title')
                                <div>{{$message}}</div>
                            @enderror
                        </div>
                        
                        <div class="mb-3">
                            <label for="url_clean">Url neta</label>
                            <input type="text" class="mt-1 block w-full" value="{{$post->url_clean}}" name="url_clean" />
                            @error('url_clean')
                                <div>{{$message}}</div>
                            @enderror
                        </div>
                       
                        <div class="mb-3">
                            <label for="content">Content</label>
                            <textarea style="@error('content') border-color:RED; @enderror" name="content" col="3" class="mt-1 block w-full">{{$post->content}}</textarea>
                            @error('content')
                                <div>{{$message}}</div>
                            @enderror
                        </div>

                        <div>
                            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Actualizar</button>
                        </div>

                    </form>

                </div>
            </div>
        </div>
    </div>

</x-app-layout>


// Para Category 
<x-app-layout>

    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Editar Categoria :') }}  {{ $category->title  }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 text-gray-900 ">
                    <form action="{{ route('categoryCRUD.update', ['categoryCRUD' => $category->id ]) }}" method="post">
                        @csrf
                        @method('PUT') 

                        <div class="mb-3">
                            <label for="title">Títol</label>
                            <input type="text" class="mt-1 block w-full" style="@error('title') border-color:RED; @enderror" value="{{$category->title}}" name="title" />
                            @error('title')
                                <div>{{$message}}</div>
                            @enderror
                        </div>

                        <div class="mb-3">
                            <label for="url_clean">Url neta</label>
                            <input type="text" class="mt-1 block w-full" style="@error('url_clean') border-color:RED; @enderror" value="{{$category->url_clean}}" name="url_clean" />
                            @error('url_clean')
                                <div>{{$message}}</div>
                            @enderror
                        </div>
                       
                        <div>
                            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Actualizar</button>
                        </div>

                    </form>

                </div>
            </div>
        </div>
    </div>

</x-app-layout>

// Probarlo todo; Create, Show, Edit, Listado, etc. 


// Nos queda un detalle bastante importante, habría que crear las rutas
// 	ahora mismo, cuando entramos solo vemos Dashboard y nada más 
// Luego crearemos una navegación para evitar tener que teclear las rutas.

// Intentamos crear algún registro con un error. 
//	genera un error, se muestra ok, pero borra la información que se ha tecleado 
// Esto también lo veremos más adelante, se modifica el create.blade.php


////////////////////////////////////////////   FIN DEL TEMA (Falta la navegación y algunos detalles de presentación) 