///////////////////////////////////////////////////////////
Finalización del CRUD

	- Navegación 
    - CKEditor 
	- Relaciones (de entidades) y Middleware
	- Relaciones: 1:1, 1:N, N:M (Desplegables)


///////////////////////////////////////////////////////////


// Acceder al dashboard y loginearse 
http://<blog-app.test>/
http://<blog-app.test>/dashboard (bmesabater@gmail.com / 12345678) 

// Veamos la parte de los LAYOUT
// Ahora mismo, ya tenemos las pantalla del CRUD más o menos bonitas y con un diseño uniforme. 
//	ante cualquier cambio, recordar siempre compilar el css de tailwindcss

λ npm run dev (Durante el desarrollo)
λ npm run build (Antes de la subida a producción) 

// Vamos a crear los link para nuestro CRUD en el menú de opciones
// 	ahora mismo, para acceder, debemos tecleamos el enlace directamente.  
// Hay que incluir el código de los link en 
//	resources>views>layouts>navigation.blade.php

// Observar que hay el siguiente código al inicio, en la primera línea
<nav x-data="{ open: false }" class="bg-white border-b border-gray-100">

// Hay una variable 'open' que le asignamos el valor 'false' 
// Este 'open' se usa más abajo mismo código para (en Hamburger) 
	<button @click="open = ! open" class="inline-flex ...
		...
		<path :class="{'hidden': open, 'inline-flex': ! open }" ... 
		<path :class="{'hidden': ! open, 'inline-flex': open }" ... 

// El Hamburger, es el menú hamburguesa, el que aparece de manera responsiva cuando la página es más pequeña (probarlo)
// 	es el menú de tres línea.  
            <div class="-me-2 flex items-center sm:hidden">

// Vamos a poner los enlaces; habrá dos tipos de enlace:
// 	Cuando la página sea completa, que ocupa toda la pantalla y hay espacio para el menú normal
// 	Cuando la página sea minimizada, ocupa pantalla pequeña y se aplica el efecto responsivo
// El código es el siguiente:

// Identificar la ubicación de  <!-- Navigation Links --> dentro de navigation.blade.php
// Observar la estructura  <x-nav-link... recordar que esto es un Component, 
//	verlo en resources>views>components>nav-link.blade.php
// Confeccionar el siguiente código (con enlaces iniciales a la lista de items)

                <!-- Navigation Links -->
                <div class="hidden space-x-8 sm:-my-px sm:ms-10 sm:flex">
                    
                    <x-nav-link :href="route('dashboard')" :active="request()->routeIs('dashboard')">
                        {{ __('Dashboard') }}
                    </x-nav-link>

                    <!-- Links para Publicaciones -->
                    <x-nav-link :href="route('postCRUD.index')" :active="request()->routeIs('postCRUD.index')">
                        {{ __('Publicaciones') }}
                    </x-nav-link>

                    <!-- Links para Categorias -->
                    <x-nav-link :href="route('categoryCRUD.index')" :active="request()->routeIs('categoryCRUD.index')">
                        {{ __('Categorias') }}
                    </x-nav-link>

                </div>

// Probarlo con 
http://blog-app.test/ (pulsar sobre dashboard o loginearse)
http://blog-app.test/dashboard

// Minimizar pantalla para comprobar como queda la responsividad-> Todavía no funciona, no hemos creado enlaces responsivos

// Y observar que en la cabezera, ahora aparecen las entradas; Dashboard / Publicaciones / Categorias
// Ir pulsando y podremos cambiar de pantalla, obviamente Publicaciones o Categorias 
//	te lleva a la primera página de la lista de Publicaciones o Categorias
// Fijarse también que la pantalla, en este menú, sale como 'activa' (resaltado y subrayado). 

// Ver como si se minimiza la pantalla, los enlaces no aparecen, no hemos añadido todavía el código para efecto responsivo 
// Hay que añadir los links en :     

<!-- Responsive Navigation Menu -->

// En esta zona del código vemos otro componente  
<x-responsive-nav-link ... > 
// que podemos inspeccionarlo en resources>views>components>responsive-nav-link.blade.php

// En navigation.blade.php en <!-- Responsive Navigation Menu --> 
// 	añadir el siguiente código, justo después de la entrada de Dashboard 

        <div class="pt-2 pb-3 space-y-1">
            <x-responsive-nav-link :href="route('postCRUD.index')" :active="request()->routeIs('postCRUD.index')">
                {{ __('Publicaciones') }}
            </x-responsive-nav-link>
        </div>

        <div class="pt-2 pb-3 space-y-1">
            <x-responsive-nav-link :href="route('categoryCRUD.index')" :active="request()->routeIs('categoryCRUD.index')">
                {{ __('Categorias') }}
            </x-responsive-nav-link>
        </div>

// Probarlo ahora forzando la responsividad. 
// Comprobar que el menú hamburguesa contiene la navegación 
http://<blog-app.test>/dashboard


///////////////////////////  CKEditor


//// Hagamos dos cosas 'especiales' 
//// Vamos a instalar el CKEditor (https://ckeditor.com/) que es un editor de texto en formato WYSIWYG que permite escribir contenido directamente dentro de 
//// las páginas web o aplicaciones en línea. Su código está escrito en JavaScript (es una librería JS) i está desarrollado por CKSource (https://cksource.com/)
//// Esto nos permitirá 'tratar' el texto, por ejemplo, el texto de las Publicaciones en el textarea, cuando las creamos / editamos, tener una herramienta
//// que nos permitan tratar el texto. 
//// El CKEditor no es el único que existe, se pueden poner otros 
//// Veámoslo:


///////////////////////////////////////   INSTALACIÓN ORIGINAL DEL CKEDITOR

****** Este plugin a cambiado el método de instalación en Laravel 


/////////////////////////////////////// PRUEBAS CKEDITOR 

// Vampos por fin a utilizarlo, hasta ahora lo que hemos hecho ha sido incluir librerias en el código html necesarias
// En resources>views>post>create.blade.php idnetificar el textarea y modificarlo como sigue añadiendo el id="editor" 

<textarea id="editor" name="content" col="3" ></textarea>

// El resources>js>ckeditor.js, que es un js, buscará todos los elementos con id="editor" para añadirles la borra de formato
// Vamos a crear un post (recordar arrancar el npm run dev para que todo funcione)

λ npm run dev
http://example-app.test/postCRUD/create


// Creamos una publicación utilizando el CKEditor, si en la lista aparece el código html en lugar de la 
// interpretación de ese código, recordar el {!! $variable !!} en lugar de un {{ $variable }}, 
// Por ejemplo, en la resource>views>post>edit.blade.php <textarea name="content" col="3">{!!$post->content!!}</textarea>
//  en resources>views>components>cards-posts.blade.php cambiar esto:

// Original
<p class="mb-4 text-base">{{ $post->content }}</p>
// Nuevo 
<p class="mb-4 text-base">{!! $post->content !!}</p>


// Y ahora sale bien, pero como el factory ha incluído código html hay algunas publicaciones que no se renderizan correctamente
// Borrar las publicaciones que creó el Factory con código html porque se vuelve loco e intenta crear una página html
// Y ahora SI se ve el formato y no el código html del formato. 
// De todas maneras, mucho ojo, porque estamos en TailwindCSS y los código html que insertes se renderizarán según tailwindcss
// Por ejemplo, si pones un H2 se verá el H2 de Tailwind, no renderizará según html estándar. 
// Se puede arreglar en la configuraciones de CKEditor (para alumnos pros)

// Hacer pruebas creando una tabla, etc. 
// Se podrían crear una estructura completa, por ejemplo, una página html (no se ha probado)
// Según CKEditor si subes una foto la textualiza (creo no se ha probado) 

///////////////////////////////////////  FIN CKEditor



////////////////////////////  RELACIONES


/////////  CREATE

// Veamos, cómo asignar Categorías a una Publicación 

http://blog-app.test/postCRUD/create 


// A una publicación cualquiera hay que poder asignarle una Category de las que tenemos. 
// Veamos cómo, y en general, veamos cómo poder gestionar las relaciones 1:N. 

// Editar el Controlador pertienente: app>Http>Controllers>PostControllerCRUD.php a la funcion create() 
// Este PostControllerCRUD está lleno de código comentado de las pruebas que hemos ido haciendo 
// Es buena idea copiarlo, para guardar los ejemplos, y tener un limpio 
// Una vez hecho backup del original, limpiar todo el código comentado 

// Añadimos el siguiente código en el método create(), para recuperar todas las Category, 
//  y recordar el import las class Category en el PostControllerCRUD.php

// Original 
    public function create()
    {
        
        return view('post.create'); // Llama a la vista create.blade.php que muestra el formulario de creación
    }

// Nuevo 
    public function create()
    {
        
        $categories = Category::all(); // Recuperamos las categorías para asignarlas en el create
        return view('post.create', ['categories' => $categories]); // Llama a la vista create.blade.php con Categories 
    }

// Y ahora, en la View resources>views>post>create.blade.php, que es donde lo recibiremos
//      primero lo probamos añadiendo un @dd() para verlo al inicio del código del formulario, justo antes del  <div class="py-12">


    </x-slot>

    @dd($categories);  // Para comprobar que se reciben las categories

    <div class="py-12">

http://blog-app.test/postCRUD/create 

 // Y deberían verse. 
      #attributes: array:7 [
        "id" => 1
        "title" => "Noves tecnologies"
        "url_clean" => "noves_tecnologies"
        "start_date" => null
        "end_date" => null
        "created_at" => "2024-09-12 13:04:34"
        "updated_at" => "2024-09-12 13:04:34"
      ]

// Así como está ahora, pasa toda la info que vemos con el @dd($categories);
// Recordar que podemos hacer que pase menos info, una info más simplificada con el 'pluck'
// Es bueno aplicarlo aquí para que sea más ágil, pensar que podría pasar mucha info
// El PostControllerCRUD.php, lo dejamos así 

    public function create()
    {
        
        //$categories = Category::all(); // Recuperamos las categorías para asignarlas en el create
        $categories = Category::pluck('id','title'); // Recuperamos las Category, solamente los campos que nos interesan 
        return view('post.create', ['categories' => $categories]); // Llama a la vista create.blade.php con Categories  
    }

// Comprobarlo otra vez 
http://blog-app.test/postCRUD/create 

// Ahora el @dd($categories); escupe una info mucho más escueta y lo que realmente necesitamos
Illuminate\Support\Collection {#1332 ▼ // resources\views/post/create.blade.php
  #items: array:8 [▼
    "Noves Tecnologies" => 1
    "Disseny personal" => 2
    "Il·lustracions" => 3
    "Art i cultura" => 4
    "TOMEU" => 6
    "HOLA QUE TAL" => 8
    "TOMMY" => 9
    "ABCDEF" => 10
  ]
  #escapeWhenCastingToString: false
}

// En el create.blade.php finalmente, borrar o comentar el  @dd($categories); 
// (Yo lo he tenido que borrar, no comenta bien y hace un desastre en el html) 

// Y ahora tendremos que añadir un desplegable de Categories.
// Añadir el siguiente código que nos renderiza el desplegable de Categories 

                        <div class="mb-3">
                            <label for="categories_id">Categories</label>
                            <select name="categories_id" class="mt-1 block w-full">
                            @foreach ($categories as $title => $id)
                                <option value="{{$id}}">{{$title}}</option>
                            @endforeach
                            </select>
                        </div> 

// Ya tenemos maquetada la página con un desplegable 1:N

// Ahora, hay que guardarlo, cuando creamos la publicación deberemos guardar también la Category seleccionada
// Para ello, acceder a PostControllerCRUD.php al método store() y observar como ahora mismo NO guardamos la Category 
// Ver como se guarda uno a uno los campos que llegan
// Para empezar, añadir un $post->category_id = $request->content; 
// Y ya que estamos podemos aprovechar y guardar también el Posted (yes / not)
//  y también eliminar el with('status','<h1>Publicación creada correctamente</h1>'); 
//  ya que si hay error lo mostrará, y si no, salta al index(), suponiendo se ha creado ok. 
/  También se podría hacer un orderBY en el index para mostrar inversamente por ID y nos 
//  mostraría el último creado. 
// Queda como sigue:

    public function store(GuardarPostRequest $request)
    {
       
        $post = new Post; 

        $post->title = $request->title;
        $post->url_clean = $request->url_clean;  
        $post->content = $request->content; 
        $post->posted = $request->posted; 
        $post->category_id = $request->categories_id; // Añade la FK de category
        $post->user_id = User::all()->random()->id; // Para que la FK user_id funcione, elegimos al azar

        $post->save(); 

        return redirect()->route('postCRUD.index'); 
    }

// Y vamos a probarlo, ahora mirando la DDBB todos tienen (uno aleatorio)
//	crear uno y comprobarlo directamente en la DDBB
http://example-app.test/postCRUD/create


// Si no renderiza bien, recordar generar las class de tailwindcss
λ npm run build // Genera el fichero de clases css, pero no rastrea cambios
λ npm run dev // Rastrea cambios y los aplica en dinámicamente

/////////  SHOW 


//// Vamos a ver cosas de las relaciones desde el punto de vista de Eloquent
// (https://laravel.com/docs/11.x/eloquent-relationships)
// Where o Join para cargar las Categorias de las publicaciones
// En app>Http>Controllers>PostControllerCRUD vamos a show()

// Y podríamos hacer lo siguiente
        // Obtenemos una categoria
        $cat = Category::where('id', $postCRUD->category_id); 

// Y luego pasarla, pero esto es hacerlo a pelo, 
// Eloquent nos deja desde el modelo (Post) poder acceder a las Category
// Vamos al app>Models>Post.php y ver que hay un método publico que se llama category()

    public function category() // 1 Post es de 1 Category
    {
      return $this->belongsTo(Category::class);  // N:1
    }

// Le estamos diciendo que tiene una relación belongsTo (un Post pertenece a una Category) 


// Revisado esto, vamos al resoruces>views>components>cards-post.blade.php 
// que es donde se renderizan las publicaciones creadas
// Llamo a este método para que me devuelva la Category y la mostramos en la View

        <h3 class="mb-2 text-xl font-medium leading-tight">{{ $post->category->title }}</h3>

// Ojo, puede generar un error si hay algún null en la DDBB 
//  en tal caso, añadiremos un condicional en el card-posts.blade.php para prevenir esta posibilidad

        @if ($post->category)
            <h3 class="mb-2 text-xl font-medium leading-tight">{{ $post->category->title }}</h3>
        @endif

// Ya ahora sí que funcionará correctamente en todos los casos



// Ejercicio: Hacer exáctamente lo mismo para user()
//  Recordar que el user, ahora mismo, se toma con una función aleatoria en el store()
//	lo que vamos haríamos es mostrarlo, en absoluto modificarlo o añadirlo en la creación
// Revisar en Model Posts el método user() y es lo mismo, se aplicaría la misma estrategia 
    public function user() 
    {
        //Relación Eloquent extracción User desde Post
        return $this->belongsTo(User::class); 
    }

// Ahora mismo, en card-posts.blade.php, añadir
        <p class="mb-4 text-sm">user: {{$post->user->name}}</p>


// Finalmente, la View card-posts.blade.php quedaría asi 

<div class="block rounded-lg bg-white shadow-secondary-1">
    <div class="p-6 text-surface">
        <h5 class="mb-2 text-xl font-medium leading-tight">{{ $post->title }}</h5>
        <h3 class="mb-2 text-xl font-medium leading-tight">{{ $post->url_clean }}</h3>
        @if ($post->category)
            <h3 class="mb-2 text-xl font-medium leading-tight">{{ $post->category->title }}</h3>
        @endif
        <p class="mb-4 text-base">{{ $post->content }}</p>
        <p class="mb-4 text-sm">user: {{$post->user->name}}</p>
        <p class="mb-4 text-sm">posted: {{ $post->posted }}</p>
        <p class="mb-4 text-sm">created at: {{ $post->created_at }}</p>
        <p class="mb-4 text-sm">updated at: {{ $post->updated_at }}</p>
        <a href="{{route('postCRUD.show' , ['postCRUD' => $post->id])}}" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Show</a>
        <a href="{{route('postCRUD.edit' , ['postCRUD' => $post->id ])}}" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Edit</a>
        <form action="{{route('postCRUD.destroy' , ['postCRUD' => $post->id ])}}" method="POST" class="float-right">
           @method('DELETE')
           @csrf
           <button type="submit" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">Delete</button>
        </form>
    </div>
</div>

// Probar que ahora se muestra todo
http://blog-app.test/postCRUD


/////////  UPDATE


// Recordar que en el PostControllerCRUD en update() tenemos una actualización masiva
    public function update(ActualizarPostRequest $request, Post $postCRUD)
    {

        $postCRUD-> update($request->all()); //Actualizamos el registro de la DDBB 
        return back(); // Vuelve a la página origen, y vuelve a cargar el registro actualizado
    }

// Porque en app>Models>Post.php tenemos definido los siguiente
    protected $fillable = [
        'title',
        'url_clean',
        'content',
    ];
// Y no así en el store(), donde tenemos por separado cada uno de los campos (porque el user_id es FK y lo tomamos como random()) 
// Si deseas hacer un guardado o actualizado masivo, hay que indicarlo en el fillable

